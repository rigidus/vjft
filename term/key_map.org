#+BEGIN_SRC c

Есть несколько разных сценариев; Опишу самые распространенные. Последовательные макроскопические события:

    Ввод: событие нажатия клавиши передается с аппаратной части клавиатуры в приложение.
    Обработка: приложение решает, что, поскольку ключ A была нажата, на ней должен отображаться символ a.
    Вывод: приложение дает команду на отображение a на экране.

Приложения с графическим интерфейсом

Де-факто стандартным графическим интерфейсом пользователя unix-систем является система X Window , часто называемая X11, поскольку она стабилизируется на 11-й версии своего основного протокола между приложениями и сервером отображения. Программа, называемая X-сервером, находится между ядром операционной системы и приложениями; он предоставляет такие услуги, как отображение окон на экране и передачу нажатий клавиш окну, находящемуся в фокусе.
Вход

+----------+              +-------------+         +-----+
| keyboard |------------->| motherboard |-------->| CPU |
+----------+              +-------------+         +-----+
             USB, PS/2, …                 PCI, …
             key down/up

Сначала информация о нажатии и отпускании клавиш передается с клавиатуры на компьютер и внутрь компьютера. Детали зависят от типа оборудования. Я не буду больше останавливаться на этой части, потому что на этом участке цепочки информация остается одинаковой: была нажата или отпущена определенная клавиша.

         +--------+        +----------+          +-------------+
-------->| kernel |------->| X server |--------->| application |
         +--------+        +----------+          +-------------+
interrupt          scancode             keysym
                   =keycode            +modifiers

Когда происходит аппаратное событие, ЦП запускает прерывание некоторого кода в ядре , которое вызывает выполнение . Этот код определяет, что аппаратное событие представляет собой нажатие или отпускание клавиши с клавиатуры, и записывает код сканирования , идентифицирующий клавишу.

X-сервер считывает входные события через файл устройства , например /dev/input/eventNNNв Linux (где NNN — число). Всякий раз, когда происходит событие, ядро ​​сигнализирует, что с этого устройства есть данные для чтения. Файл устройства передает события нажатия/нажатия клавиш с кодом сканирования, который может совпадать или не совпадать со значением, передаваемым оборудованием (ядро может транслировать код сканирования из значения, зависящего от клавиатуры, в общее значение, а Linux этого не делает). не пересылать повторно коды сканирования, которые ему неизвестны ).

X вызывает код сканирования, который считывает код ключа . X-сервер поддерживает таблицу, которая преобразует коды клавиш в символы клавиш (сокращение от «символ ключа»). Коды клавиш являются числовыми, тогда как символы клавиш представляют собой имена, такие как A, aacute, F1, KP_Add, Control_L, … Символ клавиши может отличаться в зависимости от того, какие клавиши-модификаторы нажаты ( Shift, Ctrl, …).

Существует два механизма настройки сопоставления кодов клавиш с символами клавиш:

    xmodmap — традиционный механизм. Это простая таблица, сопоставляющая коды клавиш со списком символов клавиш (немодифицированные, сдвинутые и т. д.).
    XKB — это более мощный, но более сложный механизм с лучшей поддержкой большего количества модификаторов, в частности, для двуязычной конфигурации и других.

Приложения подключаются к X-серверу и получают уведомление при нажатии клавиши, когда окно этого приложения находится в фокусе. В уведомлении указывается, что определенный символ клавиши был нажат или отпущен, а также какие модификаторы нажаты в данный момент. Вы можете увидеть символы клавиш, запустив программу xevиз терминала. То, что приложение делает с информацией, зависит от него; некоторые приложения имеют настраиваемые привязки клавиш.

В типичной конфигурации при нажатии клавиши с надписью A без модификаторов, это отправляет символ ключа aв приложение; если приложение находится в режиме ввода текста, вставляется символ a.

Связь раскладки клавиатуры и xmodmap более подробно рассматривается при вводе с клавиатуры. Как события мыши работают в Linux? дает обзор ввода с помощью мыши на нижних уровнях.
Выход

+-------------+        +----------+          +-----+         +---------+
| application |------->| X server |---····-->| GPU |-------->| monitor |
+-------------+        +----------+          +-----+         +---------+
               text or              varies          VGA, DVI,
               image                                HDMI, …

Есть два способа отображения персонажа.

    Рендеринг на стороне сервера : приложение сообщает X-серверу « нарисуйте эту строку этим шрифтом в этой позиции ». Шрифт находится на X-сервере.
    Рендеринг на стороне клиента : приложение создает изображение, которое представляет символ в выбранном им шрифте, а затем сообщает X-серверу отобразить это изображение .

См. « Каково назначение различных типов шрифтов XWindows?» для обсуждения рендеринга текста на стороне клиента и сервера в X11.

То, что происходит между X-сервером и графическим процессором (процессором видеокарты), во многом зависит от оборудования. В простых системах X-сервер использует область памяти, называемую фреймбуфером , которую графический процессор выбирает для отображения. Усовершенствованные системы, которые есть на любом ПК или смартфоне 21-го века, позволяют графическому процессору выполнять некоторые операции напрямую для повышения производительности. В конечном итоге графический процессор передает содержимое экрана попиксельно каждую долю секунды на монитор.
Приложение текстового режима, работающее в терминале

Если ваш текстовый редактор представляет собой приложение текстового режима, работающее в терминале, то именно терминал является приложением для целей раздела выше. В этом разделе я объясняю интерфейс между приложением текстового режима и терминалом. Сначала я описываю случай эмулятора терминала , работающего под X11. В чем точная разница между «терминалом», «оболочкой», «tty» и «консолью»? здесь может быть полезна предыстория. Прочитав это, вы, возможно, захотите прочитать гораздо более подробную информацию. Каковы обязанности каждого компонента псевдотерминала (PTY) (программное обеспечение, ведущая сторона, ведомая сторона)?
Вход

      +-------------------+               +-------------+
----->| terminal emulator |-------------->| application |
      +-------------------+               +-------------+
keysym                     character or
                           escape sequence

Эмулятор терминала получает такие события, как « Left был нажат, пока Shiftбыл внизу». Интерфейс между эмулятором терминала и приложением текстового режима представляет собой псевдотерминал (pty) , символьное устройство , передающее байты. Когда эмулятор терминала получает событие нажатия клавиши, он преобразует его в один или несколько байтов, которые приложение может прочитать с устройства pty.

Печатаемые символы вне диапазона ASCII передаются как один или несколько байтов в зависимости от символа и кодировки . Например, в UTF-8 кодировке набора символов Юникода символы в диапазоне ASCII кодируются как одиночные байты, а символы за пределами этого диапазона кодируются как несколько байтов.

Нажатия клавиш, соответствующие функциональной клавише или печатному символу с модификаторами, такими как Ctrl или Altотправляются как escape-последовательность . -символов Escape-последовательности обычно состоят из escape (значение байта 27 = 0x1B = \033, иногда представляемый как ^[ или \e), за которым следует один или несколько печатных символов. Некоторые клавиши или комбинации клавиш имеют соответствующий им управляющий символ в кодировках на основе ASCII (которые сегодня используются практически всеми, включая Unicode): Ctrl+ letter дает значение символа в диапазоне 1–26, Esc это escape-символ, показанный выше, он также аналогичен Ctrl+ [, Tab такой же как Ctrl+ I, Return такой же как Ctrl+ M, и т. д.

Разные терминалы отправляют разные escape-последовательности для данной клавиши или комбинации клавиш. К счастью, обратное неверно: для данной последовательности на практике существует не более одной комбинации клавиш, которую она кодирует. Единственным исключением является символ 127 = 0x7f = \0177 что часто Backspace но иногда Delete.

В терминале, если вы наберете Ctrl+ Vза которым следует комбинация клавиш, это буквально вставляет первый байт escape-последовательности из комбинации клавиш. Поскольку escape-последовательности обычно состоят только из печатных символов после первого, при этом escape-последовательность вставляется буквально. Видите таблицу привязок клавиш? для обсуждения zsh в этом контексте.

Терминал может передавать одну и ту же escape-последовательность для некоторых комбинаций модификаторов (например, многие терминалы передают пробел для обоих Space и Shift+ Space; В xterm есть режим для распознавания комбинаций модификаторов, но терминалы, основанные на популярной библиотеке vte, этого не делают ). Некоторые ключи вообще не передаются, например клавиши-модификаторы или клавиши, запускающие привязку эмулятора терминала (например, команда копирования или вставки).

Приложение может преобразовать escape-последовательности в символические имена ключей, если оно того пожелает.
Выход

+-------------+               +-------------------+
| application |-------------->| terminal emulator |--->
+-------------+               +-------------------+
               character or
               escape sequence

Вывод гораздо проще ввода. Если приложение выводит символ в файл устройства pty, эмулятор терминала отображает его в текущей позиции курсора. (Эмулятор терминала сохраняет положение курсора и прокручивает его, если курсор попадает под нижнюю часть экрана.) Приложение также может выводить escape-последовательности (в основном начиная с ^[ или ^]), чтобы указать терминалу выполнить такие действия, как перемещение курсора, изменение атрибутов текста (цвет, жирный шрифт и т. д.) или стирание части экрана.

Escape-последовательности, поддерживаемые эмулятором терминала, описаны в базе данных termcap или terminfo . Большинство эмуляторов терминала в настоящее время довольно тесно связаны с xterm . См. документацию по переменным LESS_TERMCAP_*? для более подробного обсуждения информационных баз данных о возможностях терминала, а также Как остановить мигание курсора и Могу ли я установить цвета терминала моего локального компьютера так, чтобы они использовали цвета компьютера, к которому я подключаюсь по SSH? для некоторых примеров использования.
Приложение, работающее в текстовой консоли

Если приложение запускается непосредственно в текстовой консоли, т. е. на терминале, предоставляемом ядром, а не в приложении-эмуляторе терминала, применяются те же принципы. Интерфейс между терминалом и приложением по-прежнему представляет собой поток байтов, который передает символы со специальными ключами и командами, закодированными как escape-последовательности.
Удаленное приложение, доступное по сети
Удаленное текстовое приложение

Если вы запускаете программу на удаленном компьютере, например, через SSH , то протокол сетевой связи передает данные на уровне pty.

+-------------+           +------+           +-----+           +----------+
| application |<--------->| sshd |<--------->| ssh |<--------->| terminal |
+-------------+           +------+           +-----+           +----------+
               byte stream        byte stream       byte stream
               (char/seq)         over TCP/…        (char/seq)

В основном это прозрачно, за исключением того, что иногда база данных удаленного терминала может не знать всех возможностей локального терминала.
Удаленное приложение X11

Протокол связи между приложениями и сервером сам по себе представляет собой поток байтов, который можно отправлять по сетевому протоколу, например SSH.

+-------------+            +------+        +-----+            +----------+
| application |<---------->| sshd |<------>| ssh |<---------->| X server |
+-------------+            +------+        +-----+            +----------+
               X11 protocol        X11 over       X11 protocol
                                   TCP/…

В основном это прозрачно, за исключением того, что некоторые функции ускорения, такие как декодирование фильмов и 3D-рендеринг, требующие прямой связи между приложением и дисплеем, недоступны.

#+END_SRC
