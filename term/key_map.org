#+BEGIN_SRC c

Есть несколько разных сценариев; Опишу самые распространенные. Последовательные макроскопические события:

    Ввод: событие нажатия клавиши передается с аппаратной части клавиатуры в приложение.
    Обработка: приложение решает, что, поскольку ключ A была нажата, на ней должен отображаться символ a.
    Вывод: приложение дает команду на отображение a на экране.

Приложения с графическим интерфейсом

Де-факто стандартным графическим интерфейсом пользователя unix-систем является система X Window , часто называемая X11, поскольку она стабилизируется на 11-й версии своего основного протокола между приложениями и сервером отображения. Программа, называемая X-сервером, находится между ядром операционной системы и приложениями; он предоставляет такие услуги, как отображение окон на экране и передачу нажатий клавиш окну, находящемуся в фокусе.
Вход

+----------+              +-------------+         +-----+
| keyboard |------------->| motherboard |-------->| CPU |
+----------+              +-------------+         +-----+
             USB, PS/2, …                 PCI, …
             key down/up

Сначала информация о нажатии и отпускании клавиш передается с клавиатуры на компьютер и внутрь компьютера. Детали зависят от типа оборудования. Я не буду больше останавливаться на этой части, потому что на этом участке цепочки информация остается одинаковой: была нажата или отпущена определенная клавиша.

         +--------+        +----------+          +-------------+
-------->| kernel |------->| X server |--------->| application |
         +--------+        +----------+          +-------------+
interrupt          scancode             keysym
                   =keycode            +modifiers

Когда происходит аппаратное событие, ЦП запускает прерывание некоторого кода в ядре , которое вызывает выполнение . Этот код определяет, что аппаратное событие представляет собой нажатие или отпускание клавиши с клавиатуры, и записывает код сканирования , идентифицирующий клавишу.

X-сервер считывает входные события через файл устройства , например /dev/input/eventNNNв Linux (где NNN — число). Всякий раз, когда происходит событие, ядро ​​сигнализирует, что с этого устройства есть данные для чтения. Файл устройства передает события нажатия/нажатия клавиш с кодом сканирования, который может совпадать или не совпадать со значением, передаваемым оборудованием (ядро может транслировать код сканирования из значения, зависящего от клавиатуры, в общее значение, а Linux этого не делает). не пересылать повторно коды сканирования, которые ему неизвестны ).

X вызывает код сканирования, который считывает код ключа . X-сервер поддерживает таблицу, которая преобразует коды клавиш в символы клавиш (сокращение от «символ ключа»). Коды клавиш являются числовыми, тогда как символы клавиш представляют собой имена, такие как A, aacute, F1, KP_Add, Control_L, … Символ клавиши может отличаться в зависимости от того, какие клавиши-модификаторы нажаты ( Shift, Ctrl, …).

Существует два механизма настройки сопоставления кодов клавиш с символами клавиш:

    xmodmap — традиционный механизм. Это простая таблица, сопоставляющая коды клавиш со списком символов клавиш (немодифицированные, сдвинутые и т. д.).
    XKB — это более мощный, но более сложный механизм с лучшей поддержкой большего количества модификаторов, в частности, для двуязычной конфигурации и других.

Приложения подключаются к X-серверу и получают уведомление при нажатии клавиши, когда окно этого приложения находится в фокусе. В уведомлении указывается, что определенный символ клавиши был нажат или отпущен, а также какие модификаторы нажаты в данный момент. Вы можете увидеть символы клавиш, запустив программу xevиз терминала. То, что приложение делает с информацией, зависит от него; некоторые приложения имеют настраиваемые привязки клавиш.

В типичной конфигурации при нажатии клавиши с надписью A без модификаторов, это отправляет символ ключа aв приложение; если приложение находится в режиме ввода текста, вставляется символ a.

Связь раскладки клавиатуры и xmodmap более подробно рассматривается при вводе с клавиатуры. Как события мыши работают в Linux? дает обзор ввода с помощью мыши на нижних уровнях.
Выход

+-------------+        +----------+          +-----+         +---------+
| application |------->| X server |---····-->| GPU |-------->| monitor |
+-------------+        +----------+          +-----+         +---------+
               text or              varies          VGA, DVI,
               image                                HDMI, …

Есть два способа отображения персонажа.

    Рендеринг на стороне сервера : приложение сообщает X-серверу « нарисуйте эту строку этим шрифтом в этой позиции ». Шрифт находится на X-сервере.
    Рендеринг на стороне клиента : приложение создает изображение, которое представляет символ в выбранном им шрифте, а затем сообщает X-серверу отобразить это изображение .

См. « Каково назначение различных типов шрифтов XWindows?» для обсуждения рендеринга текста на стороне клиента и сервера в X11.

То, что происходит между X-сервером и графическим процессором (процессором видеокарты), во многом зависит от оборудования. В простых системах X-сервер использует область памяти, называемую фреймбуфером , которую графический процессор выбирает для отображения. Усовершенствованные системы, которые есть на любом ПК или смартфоне 21-го века, позволяют графическому процессору выполнять некоторые операции напрямую для повышения производительности. В конечном итоге графический процессор передает содержимое экрана попиксельно каждую долю секунды на монитор.
Приложение текстового режима, работающее в терминале

Если ваш текстовый редактор представляет собой приложение текстового режима, работающее в терминале, то именно терминал является приложением для целей раздела выше. В этом разделе я объясняю интерфейс между приложением текстового режима и терминалом. Сначала я описываю случай эмулятора терминала , работающего под X11. В чем точная разница между «терминалом», «оболочкой», «tty» и «консолью»? здесь может быть полезна предыстория. Прочитав это, вы, возможно, захотите прочитать гораздо более подробную информацию. Каковы обязанности каждого компонента псевдотерминала (PTY) (программное обеспечение, ведущая сторона, ведомая сторона)?
Вход

      +-------------------+               +-------------+
----->| terminal emulator |-------------->| application |
      +-------------------+               +-------------+
keysym                     character or
                           escape sequence

Эмулятор терминала получает такие события, как « Left был нажат, пока Shiftбыл внизу». Интерфейс между эмулятором терминала и приложением текстового режима представляет собой псевдотерминал (pty) , символьное устройство , передающее байты. Когда эмулятор терминала получает событие нажатия клавиши, он преобразует его в один или несколько байтов, которые приложение может прочитать с устройства pty.

Печатаемые символы вне диапазона ASCII передаются как один или несколько байтов в зависимости от символа и кодировки . Например, в UTF-8 кодировке набора символов Юникода символы в диапазоне ASCII кодируются как одиночные байты, а символы за пределами этого диапазона кодируются как несколько байтов.

Нажатия клавиш, соответствующие функциональной клавише или печатному символу с модификаторами, такими как Ctrl или Altотправляются как escape-последовательность . -символов Escape-последовательности обычно состоят из escape (значение байта 27 = 0x1B = \033, иногда представляемый как ^[ или \e), за которым следует один или несколько печатных символов. Некоторые клавиши или комбинации клавиш имеют соответствующий им управляющий символ в кодировках на основе ASCII (которые сегодня используются практически всеми, включая Unicode): Ctrl+ letter дает значение символа в диапазоне 1–26, Esc это escape-символ, показанный выше, он также аналогичен Ctrl+ [, Tab такой же как Ctrl+ I, Return такой же как Ctrl+ M, и т. д.

Разные терминалы отправляют разные escape-последовательности для данной клавиши или комбинации клавиш. К счастью, обратное неверно: для данной последовательности на практике существует не более одной комбинации клавиш, которую она кодирует. Единственным исключением является символ 127 = 0x7f = \0177 что часто Backspace но иногда Delete.

В терминале, если вы наберете Ctrl+ Vза которым следует комбинация клавиш, это буквально вставляет первый байт escape-последовательности из комбинации клавиш. Поскольку escape-последовательности обычно состоят только из печатных символов после первого, при этом escape-последовательность вставляется буквально. Видите таблицу привязок клавиш? для обсуждения zsh в этом контексте.

Терминал может передавать одну и ту же escape-последовательность для некоторых комбинаций модификаторов (например, многие терминалы передают пробел для обоих Space и Shift+ Space; В xterm есть режим для распознавания комбинаций модификаторов, но терминалы, основанные на популярной библиотеке vte, этого не делают ). Некоторые ключи вообще не передаются, например клавиши-модификаторы или клавиши, запускающие привязку эмулятора терминала (например, команда копирования или вставки).

Приложение может преобразовать escape-последовательности в символические имена ключей, если оно того пожелает.
Выход

+-------------+               +-------------------+
| application |-------------->| terminal emulator |--->
+-------------+               +-------------------+
               character or
               escape sequence

Вывод гораздо проще ввода. Если приложение выводит символ в файл устройства pty, эмулятор терминала отображает его в текущей позиции курсора. (Эмулятор терминала сохраняет положение курсора и прокручивает его, если курсор попадает под нижнюю часть экрана.) Приложение также может выводить escape-последовательности (в основном начиная с ^[ или ^]), чтобы указать терминалу выполнить такие действия, как перемещение курсора, изменение атрибутов текста (цвет, жирный шрифт и т. д.) или стирание части экрана.

Escape-последовательности, поддерживаемые эмулятором терминала, описаны в базе данных termcap или terminfo . Большинство эмуляторов терминала в настоящее время довольно тесно связаны с xterm . См. документацию по переменным LESS_TERMCAP_*? для более подробного обсуждения информационных баз данных о возможностях терминала, а также Как остановить мигание курсора и Могу ли я установить цвета терминала моего локального компьютера так, чтобы они использовали цвета компьютера, к которому я подключаюсь по SSH? для некоторых примеров использования.
Приложение, работающее в текстовой консоли

Если приложение запускается непосредственно в текстовой консоли, т. е. на терминале, предоставляемом ядром, а не в приложении-эмуляторе терминала, применяются те же принципы. Интерфейс между терминалом и приложением по-прежнему представляет собой поток байтов, который передает символы со специальными ключами и командами, закодированными как escape-последовательности.
Удаленное приложение, доступное по сети
Удаленное текстовое приложение

Если вы запускаете программу на удаленном компьютере, например, через SSH , то протокол сетевой связи передает данные на уровне pty.

+-------------+           +------+           +-----+           +----------+
| application |<--------->| sshd |<--------->| ssh |<--------->| terminal |
+-------------+           +------+           +-----+           +----------+
               byte stream        byte stream       byte stream
               (char/seq)         over TCP/…        (char/seq)

В основном это прозрачно, за исключением того, что иногда база данных удаленного терминала может не знать всех возможностей локального терминала.
Удаленное приложение X11

Протокол связи между приложениями и сервером сам по себе представляет собой поток байтов, который можно отправлять по сетевому протоколу, например SSH.

+-------------+            +------+        +-----+            +----------+
| application |<---------->| sshd |<------>| ssh |<---------->| X server |
+-------------+            +------+        +-----+            +----------+
               X11 protocol        X11 over       X11 protocol
                                   TCP/…

В основном это прозрачно, за исключением того, что некоторые функции ускорения, такие как декодирование фильмов и 3D-рендеринг, требующие прямой связи между приложением и дисплеем, недоступны.

#+END_SRC


https://unix.stackexchange.com/questions/12510/relationship-of-keyboard-layout-and-xmodmap/12518#12518



Здесь есть два слоя: сопоставление KEYCODE с KEYSYM и сопоставление KEYSYM с текстом. Слоев больше, если считать ядро, которое должно сопоставлять скан-коды AT-клавиатуры с KEYCODE в стиле XT или HID-код USB-клавиатуры с KEYCODE. КОД КЛЮЧА — это просто 8-битное целое число без знака, которое ядро ​​операционной системы передает на сервер X11. Оно может различаться в зависимости от операционных систем, таких как Linux и Solaris. В Linux эти коды клавиш обычно имеют тот же номер, что и на старых клавиатурах ПК XT. Новые компьютеры с клавиатурами AT, PS/2 или USB обычно просто сопоставляют эти клавиатуры со старым кодом XT для ключа, чтобы упростить жизнь.

Необработанные коды клавиатуры, будь то XT, AT, PS/2 или USB, представляют собой физическое местоположение на клавиатуре. Клавиатура XT отправляет только одно 8-битное число при нажатии или отпускании клавиши. Клавиша q на американской/британской клавиатуре XT передает число 16. На французской клавиатуре та же самая физическая клавиша помечена буквой «а», но она все равно отправляет цифру 16. Реальное значение ей придают более высокие уровни операционной системы. Когда клавиша на клавиатуре XT отпускается, отправляется тот же код плюс 128. В этом примере при нажатии q отправляется 16, но при отпускании отправляется число 142 (16+128). AT-клавиатуры используют скан-коды, которые представляют собой последовательность цифр и могут быть довольно длинными. Ключевые выпуски добавляют дополнительные коды. Например, скан-код для паузы — E1, 1D, 45, E1, 9D, C5. Большинство операционных систем, включая DOS, Windows, Linux, FreeBSD и BIOS, преобразуют сканкоды в гораздо более простые сканкоды в стиле XT. Это также упрощает поддержку новых клавиатур, которые используют разные коды, таких как USB-клавиатуры, которые отправляют HID-коды. Все коды сопоставляются операционной системой с одним и тем же согласованным набором кодов до того, как X11 или приложение их увидит.

X11 не знает об этой части процесса, он просто получает КОД КЛЮЧА от ядра и применяет собственное сопоставление для преобразования этого КОДА КЛЮЧА в KEYSYM. Xmodmap — стандартный инструмент для управления этим сопоставлением. Большая часть поведения раскладки клавиатуры настраивается, но есть несколько особых случаев, таких как Num Lock, переключение режима и Caps Lock/Shift Lock, которые жестко закодированы в X11. Другие аспекты, такие как Shift, на самом деле настраиваются. Любая клавиша может быть назначена для работы в качестве клавиши Shift, в отличие от переключателя режимов или Num Lock.

КОДЫ КЛАВИШ представляют собой физические ключи, отправленные ядром операционной системы. Каждый КОД КЛЮЧА может сопоставляться с 8 возможными СИМВАМИ КЛЮЧЕЙ. Используются только 4 уровня, их иногда называют уровнями 1–4. Уровень 1 определяет KEYSYM, который печатается, когда ни один модификатор не активен. Чаще всего это строчные буквы и цифры. Модификаторы — это КОДЫ КЛАВИШ, которые изменяют СИМВОЛЫ КЛАВИШ, сгенерированные другими КОДАМИ КЛАВИШ, когда модификатор активен (нажат или включен). Коды клавиш-модификаторов также контролируются через Xmodmap. Уровень 2 определяет KEYSYM, который будет отправлен при нажатии модификатора сдвига. Уровень 3 активируется при каждом нажатии переключателя режима KEYSYM. Уровень 4 активируется, когда активны одновременно клавиша Shift и переключатель режима.

После создания KEYSYM его можно интерпретировать напрямую, но чаще всего он преобразуется в текст. Не все KEYSYM преобразуются в текст или могут повлиять только на будущие KEYSYM. Одним из примеров, конечно, является Shift_L, который не имеет текстового представления, но существует также ряд KEYSYM, которые используются для составления другого символа. Их список в моей системе находится ниже. /usr/share/X11/locale/en_US.UTF-8/Compose. Одним из таких примеров является Dead_acute KEYSYM, который при нажатии попытается преобразовать следующий KEYSYM в букву с острым ударением. Существует стандартное сопоставление для преобразования KEYSYM в Unicode.

Теперь, когда все это было сказано, обратите внимание, что Xmodmap устарел и заменен XKB, который гораздо более сложен. Это влияет на то, как KEYCODEs сопоставляется с KEYSYM, но не на то, как ядро ​​генерирует KEYCODE и не на то, как KEYSYM преобразуются в текст или составляются, что остается тем же самым. XKB можно отключить, восстановив поведение Xmodmap. У него также есть уровень совместимости для поддержки Xmodmap, но могут возникнуть проблемы, поскольку он не полностью совместим. Правила XKB находятся под /usr/share/X11/xkb/и они гораздо более совершенны. В другом месте есть хорошая документация о том, как он генерирует раскладки клавиатуры для сопоставления KEYCODE с KEYSYM.

Что касается консоли Linux, то она имеет свои собственные раскладки клавиатуры, которые хранятся в /usr/share/keymaps и загружен loadkeysкоманда. В BIOS и более ранних стадиях загрузчика, включая GRUB2, раскладка клавиатуры — это любой номер, которому BIOS решает сопоставить клавишу.


Раскладка клавиатуры ядра, как я уже сказал, загружается loadkeys одним из сценариев инициализации. grep loadkeys /etc/init.d/* показывает файл keymap.sh. X11 имеет собственную раскладку клавиш, которая традиционно загружается Xmodmap, запускаемым из одного из сценариев запуска Xsession. В настоящее время, когда вместо Xmodmap используется XKB, раскладка клавиш по умолчанию устанавливается либо в Xorg.conf с помощью различных параметров Xkb, либо через HAL. После загрузки диспетчера отображения Gnome или KDE они могут загрузить свой собственный макет через setxkbmapкоманда. Среда рабочего стола пользователя также может установить другой макет при входе в систему.


https://unix.stackexchange.com/questions/25601/how-do-mouse-events-work-in-linux/25607#25607

Если вы пишете реальную программу, использующую мышь в Linux, вы, скорее всего, пишете X-приложение, и в этом случае вам следует запросить у X-сервера события мыши. Qt , GTK и libsdl — это некоторые популярные библиотеки C, которые предоставляют функции для доступа к мыши, клавиатуре, графике, таймерам и другим функциям, необходимым для написания программ с графическим интерфейсом. Ncurses — аналогичная библиотека для терминальных приложений.

Но если вы изучаете свою систему или по какой-либо причине не можете использовать X, вот как это работает в интерфейсе ядра.

Основная идея философии UNIX заключается в том, что «все является файлом». Точнее, как можно больше вещей должно быть доступно через те же системные вызовы, которые вы используете для работы с файлами. Таким образом, интерфейс ядра для мыши представляет собой файл устройства. Ты open() это, при желании позвоните poll() или select() на нем, чтобы увидеть, есть ли входящие данные, и read() чтобы прочитать данные.

Во времена, когда не было USB, конкретным файлом устройства часто был последовательный порт, например /dev/ttyS0или порт PS/2, /dev/psaux. Вы разговаривали с мышью, используя любой аппаратный протокол, встроенный в мышь. В эти дни /dev/input/*Подсистема предпочтительнее, поскольку она обеспечивает унифицированный, независимый от устройства способ обработки множества различных устройств ввода. В частности, /dev/input/mice предоставит вам события от любой мыши, подключенной к вашей системе, и /dev/input/mouseNдаст вам события от конкретной мыши. В большинстве современных дистрибутивов Linux эти файлы создаются динамически при подключении мыши.

Для получения дополнительной информации о том, что именно вы будете читать или записывать в файл устройства мыши, вы можете начать с input/input.txt (https://www.kernel.org/doc/Documentation/input/input.txt) в документации ядра. Обратите особое внимание на разделы 3.2.2 (mousedev) и 3.2.4 (evdev), а также разделы 4 и 5.
